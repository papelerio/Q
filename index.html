<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Editor 3D — Historial Corregido</title>
  <style>
    :root{--bg:#0f1724;--panel:#0b1220;--accent:#10b981;--muted:#94a3b8;}
    html,body{height:100%;margin:0;font-family:Inter,Segoe UI,Arial;background:var(--bg);color:#e6eef8}
    #app{display:grid;grid-template-columns:320px 1fr;gap:12px;height:100vh;padding:12px;box-sizing:border-box}
    .panel{background:linear-gradient(180deg, rgba(255,255,255,0.02), transparent);border-radius:12px;padding:12px;box-shadow:0 6px 18px rgba(2,6,23,0.6)}
    header{display:flex;gap:8px;align-items:center;margin-bottom:8px}
    header h1{font-size:16px;margin:0}
    .tools{display:flex;flex-direction:column;gap:8px}
    .row{display:flex;gap:8px}
    button,select,input[type=color]{background:transparent;border:1px solid rgba(255,255,255,0.06);color:inherit;padding:8px;border-radius:8px;cursor:pointer}
    button:hover, button.active{border-color:var(--accent)}
    button:disabled{opacity:0.5;cursor:not-allowed;}
    #canvas-holder{position:relative;border-radius:12px;overflow:hidden}
    canvas{display:block;width:100%;height:100%}
    .footer{font-size:12px;color:var(--muted);margin-top:8px}
    label{font-size:13px;color:var(--muted)}
    .small{font-size:13px}
    .toolbar-grid{display:grid;grid-template-columns:repeat(2,1fr);gap:8px}
    .top-controls{display:flex;gap:8px;margin-bottom:8px}
    .scene-stats{font-size:13px;color:var(--muted);margin-top:6px}
    .notification{position:fixed;top:20px;right:20px;background:var(--accent);color:white;padding:12px 16px;border-radius:8px;z-index:1000;opacity:0;transform:translateY(-10px);transition:all 0.3s ease;}
    .notification.show{opacity:1;transform:translateY(0);}
    .history-info{font-size:11px;color:var(--muted);margin-top:4px;text-align:center;}
    .shortcut-hint{position:absolute;bottom:10px;left:10px;background:rgba(0,0,0,0.7);padding:8px 12px;border-radius:6px;font-size:12px;color:var(--muted);}
  </style>

  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.153.0/build/three.module.js"
    }
  }
  </script>
</head>
<body>
  <div id="app">
    <div class="panel" style="min-height:0;display:flex;flex-direction:column">
      <header>
        <h1>Editor 3D — Historial Corregido</h1>
      </header>

      <div class="tools">
        <div class="toolbar-grid tool-buttons">
          <button class="tool-btn active" data-mode="translate" title="Tecla 1 o G">Trasladar</button>
          <button class="tool-btn" data-mode="rotate" title="Tecla 2 o R">Rotar</button>
          <button class="tool-btn" data-mode="scale" title="Tecla 3 o S">Escalar</button>
          <button class="tool-btn" data-mode="stretch" title="Tecla 4 o E">Estirar</button>
        </div>

        <div class="row toolbar-grid">
          <button id="add-cube">Añadir Cubo</button>
          <button id="add-sphere">Añadir Esfera</button>
          <button id="add-cylinder">Añadir Cilindro</button>
          <button id="add-plane">Añadir Plano</button>
        </div>

        <div class="row">
          <select id="mode">
            <option value="translate">Trasladar</option>
            <option value="rotate">Rotar</option>
            <option value="scale">Escalar</option>
            <option value="stretch">Estirar</option>
          </select>
          <select id="space">
            <option value="world">Mundo</option>
            <option value="local">Local</option>
          </select>
        </div>

        <div class="row">
          <button id="snap">Toggle Snap</button>
          <button id="delete">Eliminar seleccionado</button>
          <button id="duplicate">Duplicar</button>
        </div>

        <div class="row">
          <label class="small">Color</label>
          <input type="color" id="color" value="#ffcc66" />
        </div>

        <div class="row">
          <button id="export-obj">Exportar .OBJ</button>
          <button id="reset-camera">Reset Cámara</button>
        </div>

        <div class="row">
          <label class="small">Grid</label>
          <select id="grid-size"><option>1</option><option>2</option><option>5</option><option>10</option></select>
          <button id="toggle-grid">Mostrar/Ocultar</button>
        </div>

        <div class="row">
          <button id="undo" title="Ctrl+Z">Deshacer (Ctrl+Z)</button>
          <button id="redo" title="Ctrl+Y">Rehacer (Ctrl+Y)</button>
        </div>

        <div class="row">
          <button id="autotest">Run Autotest</button>
        </div>

        <div class="footer">
          <div class="scene-stats">Objetos: <span id="obj-count">0</span> • Triángulos: <span id="tri-count">0</span></div>
          <div class="history-info">Historial: <span id="history-count">0</span>/20 acciones • <span id="history-position">0</span></div>
          <div style="margin-top:6px">Atajos: 1=Trasladar, 2=Rotar, 3=Escalar, 4=Estirar, G/R/S/E</div>
        </div>
      </div>
    </div>

    <div id="canvas-holder" class="panel">
      <div id="renderer-root" style="width:100%;height:100%"></div>
      <div class="shortcut-hint">
        Atajos: 1-4 o G/R/S/E para herramientas • Ctrl+Z/Y para historial
      </div>
    </div>
  </div>

  <div id="notification" class="notification"></div>

  <script type="module">
    // Import THREE via the import map
    import * as THREE from 'three';
    import { OrbitControls } from 'https://unpkg.com/three@0.153.0/examples/jsm/controls/OrbitControls.js';
    import { TransformControls } from 'https://unpkg.com/three@0.153.0/examples/jsm/controls/TransformControls.js';
    import { OBJExporter } from 'https://unpkg.com/three@0.153.0/examples/jsm/exporters/OBJExporter.js';

    // Basic app setup
    const container = document.getElementById('renderer-root');
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x071025);

    const camera = new THREE.PerspectiveCamera(60, container.clientWidth / container.clientHeight, 0.1, 2000);
    camera.position.set(4, 4, 8);

    const renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(container.clientWidth, container.clientHeight);
    container.appendChild(renderer.domElement);

    // Lights
    const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 0.7);
    hemi.position.set(0, 50, 0);
    scene.add(hemi);
    const dir = new THREE.DirectionalLight(0xffffff, 0.8);
    dir.position.set(3, 10, 4);
    scene.add(dir);

    // Grid and helpers
    let grid = new THREE.GridHelper(20, 20, 0x2c3e50, 0x14202a);
    scene.add(grid);

    const orbit = new OrbitControls(camera, renderer.domElement);
    orbit.enableDamping = true;

    // Transform controls
    const transform = new TransformControls(camera, renderer.domElement);
    transform.visible = true;
    let currentMode = 'translate';
    let initialScale = new THREE.Vector3();
    let initialPosition = new THREE.Vector3();

    transform.addEventListener('dragging-changed', function(event){ 
      orbit.enabled = !event.value; 
      if (!event.value && selected) {
        saveToHistory(currentMode);
      }
    });

    scene.add(transform);

    // Stretch handles
    const handleGroup = new THREE.Group();
    scene.add(handleGroup);
    let handles = {};

    function getHandleOffset(axis) {
      return selected.scale[axis] / 2 + 0.2;
    }

    function createHandle(axis, dir) {
      let color;
      switch (axis) {
        case 'x': color = 0xff4444; break;
        case 'y': color = 0x44ff44; break;
        case 'z': color = 0x4444ff; break;
        default: color = 0xffff44;
      }
      const geo = new THREE.BoxGeometry(0.15, 0.15, 0.15);
      const mat = new THREE.MeshBasicMaterial({ 
        color, 
        transparent: true, 
        opacity: 0.8,
        depthTest: false,
        depthWrite: false
      });
      const mesh = new THREE.Mesh(geo, mat);
      mesh.userData = { type: 'stretchHandle', axis, dir };
      return mesh;
    }

    function createStretchHandles() {
      if (!selected) return;
      handleGroup.clear();
      handles = {};
      const center = selected.position.clone();
      ['x', 'y', 'z'].forEach(ax => {
        const offset = getHandleOffset(ax);
        const axisLocal = new THREE.Vector3();
        axisLocal[ax] = 1;
        for (let sgn = 1; sgn >= -1; sgn -= 2) {
          const hkey = sgn > 0 ? `p${ax}` : `n${ax}`;
          handles[hkey] = createHandle(ax, sgn);
          handleGroup.add(handles[hkey]);
          const hDirLocal = axisLocal.clone().multiplyScalar(sgn);
          const hDirWorld = hDirLocal.applyQuaternion(selected.quaternion);
          hDirWorld.normalize();
          const handlePos = center.clone().add(hDirWorld.clone().multiplyScalar(offset));
          handles[hkey].position.copy(handlePos);
        }
      });
    }

    function updateHandlePositions(excludeActive = false) {
      if (!selected) return;
      const center = selected.position.clone();
      ['x', 'y', 'z'].forEach(ax => {
        const offset = getHandleOffset(ax);
        const axisLocal = new THREE.Vector3();
        axisLocal[ax] = 1;
        for (let sgn = 1; sgn >= -1; sgn -= 2) {
          const hkey = sgn > 0 ? `p${ax}` : `n${ax}`;
          const h = handles[hkey];
          if (excludeActive && activeHandle === h) continue;
          const hDirLocal = axisLocal.clone().multiplyScalar(sgn);
          const hDirWorld = hDirLocal.applyQuaternion(selected.quaternion);
          hDirWorld.normalize();
          const handlePos = center.clone().add(hDirWorld.clone().multiplyScalar(offset));
          h.position.copy(handlePos);
        }
      });
    }

    // SISTEMA DE HISTORIAL CORREGIDO
    const MAX_HISTORY = 20;
    let history = [];
    let historyIndex = -1;
    let isRestoring = false;

    function serializeScene() {
      const state = {
        objects: [],
        timestamp: Date.now()
      };
      
      objects.forEach(obj => {
        state.objects.push({
          uuid: obj.uuid,
          name: obj.name,
          type: obj.geometry.type,
          position: obj.position.toArray(),
          rotation: obj.rotation.toArray(),
          scale: obj.scale.toArray(),
          material: {
            color: obj.material.color.getHex(),
            emissive: obj.material.emissive ? obj.material.emissive.getHex() : 0
          }
        });
      });
      
      return state;
    }

    function restoreScene(state) {
      objects.forEach(obj => scene.remove(obj));
      objects.length = 0;
      
      state.objects.forEach(objData => {
        let geometry;
        switch(objData.type) {
          case 'BoxGeometry': geometry = new THREE.BoxGeometry(1,1,1); break;
          case 'SphereGeometry': geometry = new THREE.SphereGeometry(0.6, 32, 24); break;
          case 'CylinderGeometry': geometry = new THREE.CylinderGeometry(0.5,0.5,1,32); break;
          case 'PlaneGeometry': geometry = new THREE.PlaneGeometry(2,2); break;
          default: geometry = new THREE.BoxGeometry(1,1,1);
        }
        
        const material = new THREE.MeshStandardMaterial({
          color: objData.material.color,
          metalness: 0.1,
          roughness: 0.6,
          emissive: new THREE.Color(objData.material.emissive)
        });
        
        const mesh = new THREE.Mesh(geometry, material);
        mesh.name = objData.name;
        mesh.uuid = objData.uuid;
        mesh.position.fromArray(objData.position);
        mesh.rotation.fromArray(objData.rotation);
        mesh.scale.fromArray(objData.scale);
        
        scene.add(mesh);
        objects.push(mesh);
      });
      
      if (selected) {
        const newSelected = objects.find(obj => obj.uuid === selected.uuid);
        selectObject(newSelected);
      } else {
        selectObject(null);
      }
      
      updateStats();
    }

    function saveToHistory(actionType = 'unknown') {
      if (isRestoring) return;
      
      console.log(`Guardando historial: ${actionType}, índice actual: ${historyIndex}`);
      
      if (historyIndex < history.length - 1) {
        history = history.slice(0, historyIndex + 1);
      }
      
      const state = serializeScene();
      state.actionType = actionType;
      
      history.push(state);
      
      if (history.length > MAX_HISTORY) {
        history.shift();
      }
      
      historyIndex = history.length - 1;
      updateHistoryInfo();
    }

    function undo() {
      if (historyIndex <= 0) {
        showNotification('No hay más acciones para deshacer');
        return;
      }
      
      historyIndex--;
      isRestoring = true;
      
      console.log(`Deshacer: índice ${historyIndex + 1} -> ${historyIndex}`);
      restoreScene(history[historyIndex]);
      
      isRestoring = false;
      showNotification(`Deshecho: ${history[historyIndex].actionType} (${historyIndex + 1}/${history.length})`);
    }

    function redo() {
      if (historyIndex >= history.length - 1) {
        showNotification('No hay más acciones para rehacer');
        return;
      }
      
      historyIndex++;
      isRestoring = true;
      
      console.log(`Rehacer: índice ${historyIndex - 1} -> ${historyIndex}`);
      restoreScene(history[historyIndex]);
      
      isRestoring = false;
      showNotification(`Rehecho: ${history[historyIndex].actionType} (${historyIndex + 1}/${history.length})`);
    }

    function updateHistoryInfo() {
      document.getElementById('history-count').textContent = history.length;
      document.getElementById('history-position').textContent = `${historyIndex + 1}/${history.length}`;
      
      const undoBtn = document.getElementById('undo');
      const redoBtn = document.getElementById('redo');
      
      undoBtn.disabled = historyIndex <= 0;
      redoBtn.disabled = historyIndex >= history.length - 1;
    }

    // Selection & raycasting
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    let selected = null;

    const objects = [];
    let idCounter = 1;

    // Stretch drag variables
    let activeHandle = null;
    let isDragging = false;
    let dragStartMouse = new THREE.Vector2();
    let initialHandlePos = new THREE.Vector3();
    let currentAxisDirWorld = new THREE.Vector3();
    let currentAxisScreenUnit = new THREE.Vector2();
    let currentNDCperWorld = 0;

    function showNotification(message, duration = 3000) {
      const notification = document.getElementById('notification');
      notification.textContent = message;
      notification.classList.add('show');
      
      setTimeout(() => {
        notification.classList.remove('show');
      }, duration);
    }

    function addMaterial(color){
      return new THREE.MeshStandardMaterial({
        color, 
        metalness:0.1, 
        roughness:0.6,
        emissive: new THREE.Color(0x000000)
      });
    }

    function addPrimitive(type){
      let geom;
      switch(type){
        case 'cube': geom = new THREE.BoxGeometry(1,1,1); break;
        case 'sphere': geom = new THREE.SphereGeometry(0.6, 32, 24); break;
        case 'cylinder': geom = new THREE.CylinderGeometry(0.5,0.5,1,32); break;
        case 'plane': geom = new THREE.PlaneGeometry(2,2); break;
        default: geom = new THREE.BoxGeometry(1,1,1);
      }
      const color = document.getElementById('color').value;
      const mesh = new THREE.Mesh(geom, addMaterial(color));
      mesh.name = `${type}_${idCounter++}`;
      mesh.position.set((Math.random()-0.5)*2, 1, (Math.random()-0.5)*2);
      scene.add(mesh);
      objects.push(mesh);
      updateStats();
      selectObject(mesh);
      
      saveToHistory(`add_${type}`);
      
      return mesh;
    }

    function updateStats(){
      document.getElementById('obj-count').innerText = objects.length;
      let tris = 0;
      objects.forEach(o=>{
        if(o.geometry){
          const posCount = o.geometry.attributes.position ? o.geometry.attributes.position.count : 0;
          tris += o.geometry.index ? o.geometry.index.count/3 : posCount/3;
        }
      });
      document.getElementById('tri-count').innerText = Math.round(tris);
    }

    function selectObject(obj){
      if(selected === obj) return;
      if(selected){
        if(selected.material && selected.material.emissive) selected.material.emissive.setHex(0x000000);
      }
      selected = obj;
      if(selected){
        if(selected.material && selected.material.emissive) selected.material.emissive.setHex(0x113355);
      }
      if(currentMode === 'stretch') {
        if(selected) {
          createStretchHandles();
          initialScale.copy(selected.scale);
          initialPosition.copy(selected.position);
        } else {
          handleGroup.clear();
        }
        transform.visible = false;
        transform.detach();
      } else {
        handleGroup.clear();
        transform.visible = true;
        if(selected) {
          transform.attach(selected);
        } else {
          transform.detach();
        }
      }
    }

    function onPointerDown(e) {
      const rect = renderer.domElement.getBoundingClientRect();
      mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
      mouse.y = - ((e.clientY - rect.top) / rect.height) * 2 + 1;
      raycaster.setFromCamera(mouse, camera);
      const handleIntersects = raycaster.intersectObjects(handleGroup.children, false);
      const objIntersects = raycaster.intersectObjects(objects, false);
      if (handleIntersects.length > 0 && currentMode === 'stretch' && selected) {
        activeHandle = handleIntersects[0].object;
        dragStartMouse.copy(mouse);
        initialHandlePos.copy(activeHandle.position);
        initialScale.copy(selected.scale);
        initialPosition.copy(selected.position);
        const { axis, dir } = activeHandle.userData;
        const axisDirLocal = new THREE.Vector3();
        axisDirLocal[axis] = dir;
        currentAxisDirWorld.copy(axisDirLocal).applyQuaternion(selected.quaternion);
        currentAxisDirWorld.normalize();
        // Compute screen projection
        const point1 = initialHandlePos.clone();
        const point2 = point1.clone().add(currentAxisDirWorld.clone().multiplyScalar(0.1));
        const screen1 = point1.clone().project(camera);
        const screen2 = point2.clone().project(camera);
        const axisScreenVec = new THREE.Vector2(screen2.x - screen1.x, screen2.y - screen1.y);
        const axisScreenLength = axisScreenVec.length();
        currentAxisScreenUnit.copy(axisScreenVec).normalize();
        currentNDCperWorld = axisScreenLength / 0.1;
        isDragging = true;
        orbit.enabled = false;
        e.preventDefault();
        return;
      } else if (objIntersects.length > 0) {
        selectObject(objIntersects[0].object);
      } else {
        selectObject(null);
        activeHandle = null;
      }
    }

    function onPointerMove(e) {
      if (!isDragging || !activeHandle) return;
      const rect = renderer.domElement.getBoundingClientRect();
      mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
      mouse.y = - ((e.clientY - rect.top) / rect.height) * 2 + 1;
      const dragDeltaScreen = new THREE.Vector2().subVectors(mouse, dragStartMouse);
      const projectedNDC = dragDeltaScreen.dot(currentAxisScreenUnit);
      let deltaAlongAxis = projectedNDC / currentNDCperWorld;
      const axis = activeHandle.userData.axis;
      const scaleDelta = Math.max(deltaAlongAxis, 0.01 - initialScale[axis]);
      const newScale = initialScale[axis] + scaleDelta;
      selected.scale[axis] = newScale;
      const centerDelta = scaleDelta / 2;
      const offsetWorld = currentAxisDirWorld.clone().multiplyScalar(centerDelta);
      selected.position.copy(initialPosition).add(offsetWorld);
      const handleDelta = scaleDelta;
      const handleOffsetWorld = currentAxisDirWorld.clone().multiplyScalar(handleDelta);
      activeHandle.position.copy(initialHandlePos).add(handleOffsetWorld);
      updateHandlePositions(true);
    }

    function onPointerUp(e) {
      if (isDragging) {
        isDragging = false;
        orbit.enabled = true;
        updateHandlePositions(false);
        activeHandle = null;
        saveToHistory('stretch');
      }
    }

    renderer.domElement.addEventListener('pointerdown', onPointerDown);
    renderer.domElement.addEventListener('pointermove', onPointerMove);
    renderer.domElement.addEventListener('pointerup', onPointerUp);

    document.getElementById('add-cube').addEventListener('click', ()=>addPrimitive('cube'));
    document.getElementById('add-sphere').addEventListener('click', ()=>addPrimitive('sphere'));
    document.getElementById('add-cylinder').addEventListener('click', ()=>addPrimitive('cylinder'));
    document.getElementById('add-plane').addEventListener('click', ()=>addPrimitive('plane'));

    document.getElementById('mode').addEventListener('change', (e)=>{
      const newMode = e.target.value;
      const wasStretch = currentMode === 'stretch';
      currentMode = newMode;
      if(newMode === 'stretch') {
        transform.setMode('scale');
        transform.visible = false;
        if(selected) {
          createStretchHandles();
          initialScale.copy(selected.scale);
          initialPosition.copy(selected.position);
        }
        showNotification('Modo Estirar: arrastra los manejadores para estirar en cualquier dirección');
      } else {
        transform.setMode(newMode);
        transform.visible = true;
        handleGroup.clear();
        if(selected) {
          transform.attach(selected);
        }
      }
      updateToolButtons(newMode);
    });

    function updateToolButtons(mode) {
      document.querySelectorAll('.tool-btn').forEach(btn => {
        btn.classList.remove('active');
      });
      
      const toolBtn = document.querySelector(`.tool-btn[data-mode="${mode}"]`);
      if (toolBtn) {
        toolBtn.classList.add('active');
      }
    }

    document.getElementById('space').addEventListener('change', (e)=>{
      transform.setSpace(e.target.value);
      if (currentMode === 'stretch' && selected) {
        createStretchHandles();
      }
    });

    document.getElementById('delete').addEventListener('click', ()=>{
      if(!selected) return;
      
      saveToHistory('delete');
      
      scene.remove(selected);
      const idx = objects.indexOf(selected);
      if(idx>=0) objects.splice(idx,1);
      transform.detach();
      handleGroup.clear();
      selected=null;
      updateStats();
      showNotification('Objeto eliminado');
    });

    document.getElementById('duplicate').addEventListener('click', ()=>{
      if(!selected) return;
      
      saveToHistory('duplicate');
      
      const clone = selected.clone();
      clone.geometry = selected.geometry.clone();
      clone.material = selected.material.clone();
      clone.position.x += 0.5;
      scene.add(clone);
      objects.push(clone);
      selectObject(clone);
      updateStats();
      showNotification('Objeto duplicado');
    });

    let snapEnabled = false;
    document.getElementById('snap').addEventListener('click', ()=>{
      snapEnabled = !snapEnabled;
      transform.setTranslationSnap(snapEnabled ? 0.5 : 0);
      transform.setRotationSnap(snapEnabled ? THREE.MathUtils.degToRad(15) : 0);
      transform.setScaleSnap(snapEnabled ? 0.1 : 0);
      showNotification('Snap ' + (snapEnabled ? 'activado' : 'desactivado'));
    });

    document.getElementById('export-obj').addEventListener('click', ()=>{
      try{
        if (objects.length === 0) {
          showNotification('No hay objetos para exportar');
          return;
        }
        
        const exporter = new OBJExporter();
        const exportScene = new THREE.Scene();
        
        objects.forEach(obj => {
          if (obj.isMesh) {
            const clone = obj.clone();
            if (clone.material && !clone.material.name) {
              clone.material.name = `material_${obj.name}`;
            }
            exportScene.add(clone);
          }
        });
        
        const result = exporter.parse(exportScene);
        
        if (!result || result.trim().length === 0) {
          throw new Error('El archivo OBJ está vacío');
        }
        
        const blob = new Blob([result], {type: 'text/plain;charset=utf-8'});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        
        const name = prompt('Nombre del archivo (sin extensión)', 'scene') || 'scene';
        a.download = name + '.obj';
        
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        
        setTimeout(() => {
          URL.revokeObjectURL(url);
        }, 5000);
        
        showNotification(`Archivo ${name}.obj descargado correctamente`);
        
      }catch(err){
        console.error('Error exporting OBJ:', err);
        showNotification('Error al exportar OBJ: ' + err.message, 5000);
      }
    });

    document.getElementById('reset-camera').addEventListener('click', ()=>{
      camera.position.set(4,4,8); 
      orbit.target.set(0,0,0);
      orbit.update();
      showNotification('Cámara reiniciada');
    });

    document.getElementById('toggle-grid').addEventListener('click', ()=>{ 
      grid.visible = !grid.visible; 
      showNotification('Grid ' + (grid.visible ? 'mostrado' : 'oculto'));
    });
    
    document.getElementById('grid-size').addEventListener('change', (e)=>{
      const s = parseFloat(e.target.value) || 1;
      scene.remove(grid);
      grid = new THREE.GridHelper(20*s, 20*s, 0x2c3e50, 0x14202a);
      scene.add(grid);
    });

    document.getElementById('undo').addEventListener('click', undo);
    document.getElementById('redo').addEventListener('click', redo);

    document.querySelectorAll('.tool-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        const mode = btn.getAttribute('data-mode');
        const wasStretch = currentMode === 'stretch';
        currentMode = mode;
        if (mode === 'stretch') {
          transform.setMode('scale');
          transform.visible = false;
          if (selected) {
            createStretchHandles();
            initialScale.copy(selected.scale);
            initialPosition.copy(selected.position);
          }
          showNotification('Modo Estirar: arrastra los manejadores para estirar en cualquier dirección');
        } else {
          transform.setMode(mode);
          transform.visible = true;
          handleGroup.clear();
          if (selected) {
            transform.attach(selected);
          }
        }
        document.getElementById('mode').value = mode;
        updateToolButtons(mode);
      });
    });

    document.getElementById('color').addEventListener('input', (e)=>{
      if(selected && selected.material && selected.material.color){
        selected.material.color.set(e.target.value);
        saveToHistory('color_change');
      }
    });

    async function runAutotest(){
      try{
        const before = objects.length;
        const c = addPrimitive('cube');
        const s = addPrimitive('sphere');
        selectObject(c);
        document.getElementById('duplicate').click();
        const after = objects.length;
        const exporter = new OBJExporter();
        const out = exporter.parse(scene);
        const ok = after >= before + 3 && typeof out === 'string' && out.length > 20;
        showNotification('Autotest ' + (ok ? 'PASÓ' : 'FALLÓ') + ` — objetos: ${before}→${after}, export length: ${out.length}`);
      }catch(e){
        console.error('Autotest error', e);
        showNotification('Autotest falló — revisa la consola.', 5000);
      }
    }
    document.getElementById('autotest').addEventListener('click', runAutotest);

    window.addEventListener('resize', ()=>{
      camera.aspect = container.clientWidth / container.clientHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(container.clientWidth, container.clientHeight);
    });

    window.addEventListener('keydown', (e)=>{
      if(e.key === '1' || e.key === 'g'){ 
        e.preventDefault();
        const mode = 'translate';
        if (currentMode !== mode) {
          currentMode = mode;
          transform.setMode(mode);
          document.getElementById('mode').value = mode;
          updateToolButtons(mode);
          handleGroup.clear();
          transform.visible = true;
          if (selected) transform.attach(selected);
        }
      }
      if(e.key === '2' || e.key === 'r'){ 
        e.preventDefault();
        const mode = 'rotate';
        if (currentMode !== mode) {
          currentMode = mode;
          transform.setMode(mode);
          document.getElementById('mode').value = mode;
          updateToolButtons(mode);
          handleGroup.clear();
          transform.visible = true;
          if (selected) transform.attach(selected);
        }
      }
      if(e.key === '3' || e.key === 's'){ 
        e.preventDefault();
        const mode = 'scale';
        if (currentMode !== mode) {
          currentMode = mode;
          transform.setMode(mode);
          document.getElementById('mode').value = mode;
          updateToolButtons(mode);
          handleGroup.clear();
          transform.visible = true;
          if (selected) transform.attach(selected);
        }
      }
      if(e.key === '4' || e.key === 'e'){ 
        e.preventDefault();
        const mode = 'stretch';
        if (currentMode !== mode) {
          currentMode = mode;
          transform.setMode('scale');
          document.getElementById('mode').value = mode;
          updateToolButtons(mode);
          transform.visible = false;
          if (selected) {
            createStretchHandles();
            initialScale.copy(selected.scale);
            initialPosition.copy(selected.position);
          }
          showNotification('Modo Estirar: arrastra los manejadores para estirar en cualquier dirección');
        }
      }
      
      if(e.ctrlKey && e.key.toLowerCase() === 'z'){ 
        e.preventDefault(); 
        undo();
      }
      if(e.ctrlKey && e.key.toLowerCase() === 'y'){ 
        e.preventDefault(); 
        redo();
      }
      
      if(e.key === 'Delete'){ if(selected){ document.getElementById('delete').click(); }}
      if(e.ctrlKey && e.key.toLowerCase() === 'd'){ e.preventDefault(); document.getElementById('duplicate').click(); }
    });

    function animate(){
      requestAnimationFrame(animate);
      orbit.update();
      renderer.render(scene, camera);
    }
    
    animate();

    addPrimitive('cube');
    addPrimitive('sphere');
    updateStats();
    saveToHistory('initial');
  </script>
</body>
</html>
